#!/usr/bin/env python

'''
* Team ID: 7415
* Author List : Yash Varshney, Anurag Saxena and Aman Tyagi
* Filename: 
* Theme: Survey_and_Rescue
* Functions : load_rois(), image_callback(), serviced_callback(), find_colour_contour_centers(), main()
* Global Variables : None
'''

from __future__ import print_function
import roslib
import sys
import rospy
import cv2
import numpy as np
from std_msgs.msg import String
from sensor_msgs.msg import Image
from survey_and_rescue.msg import *
from cv_bridge import CvBridge, CvBridgeError
import random
import pickle
import imutils
import copy


class sr_determine_colors():

	def __init__(self):
		
		self.loc_dictionary = {
							'A1':"",'A2':"",'A3':"",'A4':"",'A5':"",'A6':"",'B1':"",'B2':"",'B3':"",'B4':"",'B5':"",'B6':"",'C1':"",'C2':"",'C3':"",'C4':"",'C5':"",'C6':"",
								'D1':"",'D2':"",'D3':"",'D4':"",'D5':"",'D6':"",'E1':"",'E2':"",'E3':"",'E4':"",'E5':"",'E6':"",'F1':"",'F2':"",'F3':"",'F4':"",'F5':"",'F6':""
										}			# To store the events

		self.bridge = CvBridge()			#making self.bridge object of CvBridge class
		self.detect_pub = rospy.Publisher("/detection_info",SRInfo,queue_size=10)					#Publisher to publish on /detection_info node 
 		self.image_sub = rospy.Subscriber("/usb_cam/image_rect_color",Image,self.image_callback)	#Subscribing to /usb_cam/image_rect_color
 		self.serviced_sub = rospy.Subscriber('/serviced_info',SRInfo,self.serviced_callback)		#Subscribing to /serviced_info            
 																									# This is giving a feedback generated by monitor.pyc
 																									
 																									# that wether the service was succfull or a failure in
 																									# this format location: "A2"
																									# info: "FAILURE"
		


		self.msg = SRInfo()										# making self.msg of type SRInfo()
		self.msg.location=""
		self.msg.info = ""

		self.serviced_loc = ""									# to store the serviced callback location
		
		# to store info related to countours.
		self.area = 0
		self.b = 0
		self.cx = 0
		self.cy = 0
		self.M = 0

		#declaring threshold hsv values for image processing
		self.lower_red = np.array([122,114,000]) 
		self.upper_red = np.array([255,255,255]) 

		self.lower_green = np.array([26,76,40]) 
		self.upper_green = np.array([80,255,255]) 

		self.lower_blue = np.array([101,230,070]) 
		self.upper_blue = np.array([149,255,255]) 

		# declearing and initializing self.img variable to store the image in image_callback
		self.img = np.array([0,0,0])
		self.hsv = self.img

		# to store different colours masks
		self.mask_red = 0
		self.mask_green = 0
		self.mask_blue = 0

		# to store contours of different colours
		self.contours_red = 0
		self.contours_green = 0
		self.contours_blue = 0

		# to store sorted contours area for different colours
		self.area_sorted_contours_red = []
		self.area_sorted_contours_green = []
		self.area_sorted_contours_blue = []

		# for different events
		self.event_red= ""
		self.event_green= ""
		self.event_blue= ""

		# to store all the countours.
		self.contour_list = []

'''		

* Function name :		load_rois 
* Inputs :				self or NONE
* output :				contour_list, containing detected contours as a list 
* Logc :				opening contours.pkl file and storing it in self.contour_list
* Example call :		object_name.load_rois

'''
	def load_rois(self, file_path = 'rect_info.pkl'): # loading pickle file in which contours are stored 
		try:

			with open("contours.pkl", 'rb') as input:
   				self.contour_list = pickle.load(input)
   		except IOError, ValueError:
			print("File doesn't exist or is corrupted")

'''

* Function :		image_callback()
* Input:			data of type /usb_cam/image_rect_color
* Output :			NONE 
* Logic :			callback function of subscriber /usb_cam/image_rect_color and changing it to hsv values
* Example call :	the function excuted each time when /usb_cam publishes the message on /image_rect_color

'''

 	def image_callback(self, data):
 		try:
 			self.img = self.bridge.imgmsg_to_cv2(data, "bgr8")
 			self.hsv = cv2.cvtColor(self.img,cv2.COLOR_BGR2HSV)
 			cv2.waitKey(10)
			
 		except CvBridgeError as e:
 			print(e)

'''

* Function :		serviced_callback()
* Input :			data of type SRInfo
* Output :			NONE
* Logic :			when function is called make the self.loc_dictionary msg.location element "" (null)
* Example call :	the function excuted each time when data is published on /serviced_info

'''

 	def serviced_callback(self, msg):
 		self.serviced_loc = msg.location
 		rospy.sleep(0.5)
 		self.loc_dictionary[self.serviced_loc] = ""
'''

* Function :		find_color_contour_centers()
* Input :			None
* Output :			Publishing message
* Logic :			making masks for hsv values of input image by inRange function, finding contours of each masks by using 
					findContours function and storing them to variables. for contours of each color, sorting them accorting to its area
					and appending them to a list. again another for loop finds the center of the contours, applying point polygon test
					for each center co-ordinates if result is 0 or 1 then declaring the event as "RESCUE", "FOOD" or "MEDICINE" 
					publishing the location and info of the event after compairing it with self.loc_dictionary.
* Example call :	object_name.find_color_contour_centers()
'''
	def find_color_contour_centers(self):

		self.mask_red = cv2.inRange(self.hsv, self.lower_red, self.upper_red)
		self.mask_green = cv2.inRange(self.hsv, self.lower_green, self.upper_green)
		self.mask_blue = cv2.inRange(self.hsv, self.lower_blue, self.upper_blue)

		_, self.contours_red,_ = cv2.findContours(self.mask_red,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE) #finding contours 
		_, self.contours_green,_ = cv2.findContours(self.mask_green,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
		_, self.contours_blue,_ = cv2.findContours(self.mask_blue,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)



		for self.contours_red in self.contours_red: #Sorting contours according to area 
			self.area = cv2.contourArea(self.contours_red)
			if (self.area >150 and self.area <1000 ): 
				self.area_sorted_contours_red.append(self.contours_red) #saving sorted contours in list
				
		for self.b in self.area_sorted_contours_red:
			self.M =cv2.moments(self.b)
			self.cx = int (self.M["m10"]/self.M["m00"]) #for finding x co-ordinate of centre
			self.cy = int (self.M["m01"]/self.M["m00"]) #for finding y co-ordinate of centre			
			
		
			
			self.area_sorted_contours_red = []
			for self.x in self.contour_list:
				#Performing pointPolygonTest to check if the point is inside the polygon or not 
				self.dist = cv2.pointPolygonTest(self.contour_list[self.x],(self.cx,self.cy),False) 
				
				if(self.dist==1 or self.dist==0):
						self.event_red ="RESCUE"
						if(self.event_red != self.check_dictionary[self.x]): #
						
							self.check_dictionary[self.x]=self.event_red
							self.msg.location= self.x
							self.msg.info = self.check_dictionary[self.x]
						
							self.detect_pub.publish(self.msg) #publishing the msg
				
			

			


		for self.contours_green in self.contours_green:
			self.area = cv2.contourArea(self.contours_green)
			if (self.area >500 and self.area <2500 ):
				self.area_sorted_contours_green.append(self.contours_green)
		for self.b in self.area_sorted_contours_green:
			self.M =cv2.moments(self.b)
			self.cx = int (self.M["m10"]/self.M["m00"])
			self.cy = int (self.M["m01"]/self.M["m00"])
			
			
			self.area_sorted_contours_green = []

			for self.x in self.contour_list:

				self.dist = cv2.pointPolygonTest(self.contour_list[self.x],(self.cx,self.cy),False)
			
				if(self.dist==1 or self.dist==0):
						self.event_green ="FOOD"
						if(self.event_green != self.check_dictionary[self.x]):
							self.check_dictionary[self.x]=self.event_green
							
							self.msg.location= self.x
							self.msg.info = self.check_dictionary[self.x]
							self.detect_pub.publish(self.msg)
				

			


		for self.contours_blue in self.contours_blue:
			self.area = cv2.contourArea(self.contours_blue)
			if (self.area >200 and self.area <1550):
				self.area_sorted_contours_blue.append(self.contours_blue)
		for self.b in self.area_sorted_contours_blue:
			self.M =cv2.moments(self.b)
			self.cx = int (self.M["m10"]/self.M["m00"]) #for finding x co-ordinate of centre
			self.cy = int (self.M["m01"]/self.M["m00"]) #for finding y co-ordinate of centre
			
			for self.x in self.contour_list:
				self.dist = cv2.pointPolygonTest(self.contour_list[self.x],(self.cx,self.cy),False)				
				if(self.dist==1 or self.dist==0):
						self.event_blue ="MEDICINE"
						if(self.event_blue == self.check_dictionary[self.x]):
							pass
						else:
							self.check_dictionary[self.x]=self.event_blue
							
							self.msg.location= self.x
							self.msg.info = self.check_dictionary[self.x]
							
							self.detect_pub.publish(self.msg)
				
		self.area_sorted_contours_blue = [] 
				



def main(args):
	
	try:
		rospy.init_node('sr_beacon_detector', anonymous=False)
		s = sr_determine_colors()
		rate = rospy.Rate(30)
		s.load_rois()
		while s.img is None:
			print("Can't get the image")
	except KeyboardInterrupt:
		cv2.destroyAllWindows()
	while not rospy.is_shutdown():
		try:
			s.find_color_contour_centers()
			s.check_whether_lit()
			rate.sleep()
		except KeyboardInterrupt:
			cv2.destroyAllWindows()
		rospy.sleep(1)

if __name__ == '__main__':
    main(sys.argv)

 
